//@author: a0094213m



	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp
	 */

#include "DateTime.h"

const string DateTime::DATETYPE_MONDAY1 = "Monday";
const string DateTime::DATETYPE_MONDAY2 = "Mon";
const string DateTime::DATETYPE_MONDAY3 = "monday";
const string DateTime::DATETYPE_MONDAY4 = "mon";
const string DateTime::DATETYPE_TUESDAY1 = "Tuesday";
const string DateTime::DATETYPE_TUESDAY2 = "Tues";
const string DateTime::DATETYPE_TUESDAY3 = "tuesday";
const string DateTime::DATETYPE_TUESDAY4 = "tues";
const string DateTime::DATETYPE_WEDNESDAY1 = "Wednesday";
const string DateTime::DATETYPE_WEDNESDAY2 = "Wed";
const string DateTime::DATETYPE_WEDNESDAY3 = "wednesday";
const string DateTime::DATETYPE_WEDNESDAY4 = "wed";
const string DateTime::DATETYPE_THURSDAY1 = "Thursday";
const string DateTime::DATETYPE_THURSDAY2 = "Thurs";
const string DateTime::DATETYPE_THURSDAY3 = "thursday";
const string DateTime::DATETYPE_THURSDAY4 = "thurs";
const string DateTime::DATETYPE_FRIDAY1 = "Friday";
const string DateTime::DATETYPE_FRIDAY2 = "Fri";
const string DateTime::DATETYPE_FRIDAY3 = "friday";
const string DateTime::DATETYPE_FRIDAY4 = "fri";
const string DateTime::DATETYPE_SATURDAY1 = "Saturday";
const string DateTime::DATETYPE_SATURDAY2 = "Sat";
const string DateTime::DATETYPE_SATURDAY3 = "saturday";
const string DateTime::DATETYPE_SATURDAY4 = "sat";
const string DateTime::DATETYPE_SUNDAY1 = "Sunday";
const string DateTime::DATETYPE_SUNDAY2 = "Sun";
const string DateTime::DATETYPE_SUNDAY3 = "sunday";
const string DateTime::DATETYPE_SUNDAY4 = "sun";
const string DateTime::DATETYPE_TODAY1 = "today";
const string DateTime::DATETYPE_TOMORROW1 = "tomorrow";
const string DateTime::DATETYPE_TOMORROW2 = "tmr";

const string DateTime::TIMETYPE_AM = "am";
const string DateTime::TIMETYPE_PM = "pm";

const string DateTime::_MONTH_JANUARY = "January";
const string DateTime::_MONTH_FEBRUARY = "February";
const string DateTime::_MONTH_MARCH = "March";
const string DateTime::_MONTH_APRIL = "April";
const string DateTime::_MONTH_MAY = "May";
const string DateTime::_MONTH_JUNE = "June";
const string DateTime::_MONTH_JULY = "July";
const string DateTime::_MONTH_AUGUST = "August";
const string DateTime::_MONTH_SEPTEMBER = "September";
const string DateTime::_MONTH_OCTOBER = "October";
const string DateTime::_MONTH_NOVEMBER = "November";
const string DateTime::_MONTH_DECEMBER = "December";




bool DateTime::isInitialized = false;
int DateTime::numberOfDateType;
int DateTime::numberOfTimeType;
vector<string> DateTime::dateType;
vector<string> DateTime::timeType;


	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp
	 */

DateTime::DateTime(){
	isDateSet = false;
	isTimeSet = false;
	Initialize();
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp
	 */

DateTime::DateTime(string input){
	unformattedDateTime = input;
	isValidFormat = true;
	isDateSet = false;
	isTimeSet = false;
	Initialize();
	SetDefaultDateTime();
	SetStandards();
}


DateTime::~DateTime(){
}


void DateTime::SetDefaultDateTime(){
	time_t current = time(0);
	struct tm timeinfo;
	localtime_s(&timeinfo, &current);
	_day = timeinfo.tm_mday;
	_month = timeinfo.tm_mon + 1;
	_year = timeinfo.tm_year + 1900;
	_hours = 0;
	_mins = 0;
}

void DateTime::SetStandards(){
	formattedDateTime = unformattedDateTime;
	string dbg = unformattedDateTime;
	string date;
	string time;
	Smartstring input_s(unformattedDateTime);
	vector<string> tokens = input_s.Tokenize(" ");
	int size = tokens.size();

	try{
		if (size > 3){
			isValidFormat = false;
		}
		else{
			switch (size){
			case 0:{
				isValidFormat = false;
				break;
			}
			case 1:{
				//this case assumes only either date or time has been entered
				formattedDateTime = StandardizeSingle(tokens[0]);
				break;
			}

			case 3:{
				formattedDateTime = StandardizeTriple(tokens);
				break;
			}

			default: {
				isValidFormat = false;
				break;
			}
			}
		}
	}
	catch (out_of_range){
		cout << "exception occurs: size out of range" << endl;

	}
}

string DateTime::StandardizeSingle(string input){
	string standard;
	string single = input;

	assert(single != "");

	if (IsValidDayDate(single)){
		standard = StandardizeDayDate(single);
	}
	else{
		if (IsValidTime(single)){
			standard = StandardizeTime(single);
		}
		else{
			standard = single;
			isValidFormat = false;
		}
	}
	return standard;
}

string DateTime::StandardizeTriple(vector<string> input){
	string standard;
	string date;
	string time;

	if (input[1] == "at"){
		//assumption: date before "at" and time after "at"  for example: friday at 5pm
		assert(IsValidTime(input[2]));

		if (IsValidDayDate(input[0])){
			date = StandardizeDayDate(input[0]);

		}
		else{
			date = input[0];
			isValidFormat = false;
		}

		if (IsValidTime(input[2])){
			time = StandardizeTime(input[2]);
		}
		else{
			time = input[2];
			isValidFormat = false;
		}

	}
	else{
		if (input[1] == "on" || input[1] == "by"){

			if (IsValidDayDate(input[2])){
				date = StandardizeDayDate(input[2]);
			}
			else{
				date = input[2];
				isValidFormat = false;
			}
			if (IsValidTime(input[0])){
				time = StandardizeTime(input[0]);
			}
			else{
				time = input[0];
				isValidFormat = false;
			}
		}
	}

	standard = time + " on " + date;
	return standard;
}


string DateTime::StandardizeDayDate(string input){
	string standard = input;

	if (IsValidDay(input)){
		standard = StandardizeDay(input);
	}
	if (IsValidDate(input)){
		standard = StandardizeDate(input);
	}

	return standard;
}

string DateTime::StandardizeDate(string input){
	string standard;
	Smartstring input_s(input);
	vector<string> tokens = input_s.Tokenize("/");

	while (tokens.size() < 3){
		tokens.push_back("");
	}
	assert(tokens.size() == 3);

	int day = atoi(tokens[0].c_str());
	int month = atoi(tokens[1].c_str());
	if (month > 12 || day > 12){
		int temp = month;
		month = day;
		day = temp;
	}

	_day = day;
	_month = month;
	_year = atoi(tokens[2].c_str());
	isDateSet = true;
	ostringstream month_s;
	month_s << setw(2) << setfill('0') << month;
	ostringstream day_s;
	day_s << setw(2) << setfill('0') << day;

	standard = day_s.str() + "/" + month_s.str() + "/" + tokens[2];
	return standard;
}

string DateTime::StandardizeDay(string input){
	string standard;
	string today;
	time_t now = time(0);
	int offset;
	DAY startday, endday;


	endday = GetDayEnum(input);
	today = GetDayFromTime(now);
	startday = GetDayEnum(today);

	if (endday != DAY::INVALID && startday != DAY::INVALID){
		int offset_in_days = CalculateOffset(startday, endday);
		time_t timeresult = OffsetByDay(now, offset_in_days);
		standard = GetStandardDate(timeresult);

		struct tm timeinfo;
		localtime_s(&timeinfo, &timeresult);
		_day = timeinfo.tm_mday;
		_month = timeinfo.tm_mon + 1;
		_year = timeinfo.tm_year + 1900;
		isDateSet = true;
	}
	else{
		standard = input;
	}

	return standard;
}

string DateTime::StandardizeTime(string input){
	assert(input != "");
	string standard;
	string result = input;
	string period = "am";
	int found;
	int hour;
	int mins;


	found = input.find("pm");
	if (found != string::npos){
		period = "pm";
		result = input.substr(0, found);
	}
	found = result.find("am");
	if (found != string::npos){
		period = "am";
		result = result.substr(0, found);
	}


	found = result.find_first_of(":");
	if (found != string::npos){
		string hour_s = result.substr(0, found);
		hour = stoi(hour_s.c_str());
		int length = result.length();
		string min_s = result.substr(found + 1, length - 1);
		mins = stoi(min_s.c_str());
	}
	else{
		if (result.length() <= 2){
			hour = atoi(result.c_str());
			mins = 0;
		}
	}
	//if the input has hour exceeding 12, change it to time with pm
	if (hour > 12){
		hour = hour % 12;
		period = "pm";
	}

	//store time info in private variables 
	if (period == "pm"){
		_hours = hour % 12 + 12;
		_mins = mins % 60;
	}
	else{
		_hours = hour % 24;
		_mins = mins % 60;
	}

	isTimeSet = true;


	ostringstream minout;
	minout << setw(2) << setfill('0') << mins;
	ostringstream hourout;
	hourout << setw(2) << setfill('0') << hour;

	standard = hourout.str() + ":" + minout.str() + period;
	return standard;
}

string DateTime::Standardized(){
	return formattedDateTime;
}


string DateTime::GetInfo(){
	ostringstream info;

	info << "Date: " << setw(2) << setfill('0')
		<< _day << "/" << setw(2) << setfill('0')
		<< _month << "/" << setw(2) << setfill('0')
		<< _year << endl;

	info << "Time: " << setw(2) << setfill('0')
		<< _hours << ":" << setw(2) << setfill('0')
		<< _mins;

	return info.str();
}

string DateTime::GetDate(){
	ostringstream date;
	date << _day << "/" << _month << "/" << _year;
	return date.str();
}

string DateTime::GetDateWithoutYear(){
	ostringstream date;
	int db = _month;
	string month = GetMonthName(_month);
	date << _day << " " << month;
	return date.str();
}

string DateTime::GetTime(){
	if (isTimeSet){
		ostringstream time;
		time << setw(2) << setfill('0') << _hours << ":" << setw(2) << setfill('0') << _mins;
		string dbg = time.str();
		return time.str();
	}
	else{
		return "";
	}
}


bool DateTime::IsEarlierThan(DateTime dt){
	bool isEarlier = false;

	if (_year < dt._year){
		isEarlier = true;
	}
	else if (_year == dt._year){
		if (_month < dt._month){
			isEarlier = true;
		}
		else if (_month == dt._month){
			if (_day < dt._day){
				isEarlier = true;
			}
			else if (_day == dt._day){
				if (_hours < dt._hours){
					isEarlier = true;
				}
				else if (_hours == dt._hours){
					if (_mins < dt._mins){
						isEarlier = true;
					}
				}
			}
		}
	}

	return isEarlier;
}


string DateTime::TwentyFourHourFormat(){
	string output;
	ostringstream min;
	ostringstream hour;

	min << setw(2) << setfill('0') << _mins;
	hour << setw(2) << setfill('0') << _hours;

	output = hour.str() + ":" + min.str();
	return output;
}

bool DateTime::IsValidDayDate(string input){
	if (IsValidDay(input) || IsValidDate(input)){
		return true;
	}
	else{
		return false;
	}
}

bool DateTime::IsValidDate(string input){
	assert(input != "");
	string dbg = input;
	int endIdx = 0;
	int startIdx = 0;
	int count = 0;
	bool isValid = false;

	while (endIdx != string::npos){
		endIdx = input.find_first_of("/", startIdx);
		if (endIdx != string::npos){
			count++;
		}
		startIdx = endIdx + 1;
	}

	if (count == 2){
		isValid = true;
	}

	return isValid;
}

bool DateTime::IsValidDay(string input){
	int found;

	for (int i = 0; i < numberOfDateType; i++){
		found = input.find(dateType[i]);

		if (found != string::npos){
			return true;
		}
	}

	return false;

}

bool DateTime::IsValidTime(string input){
	assert(input != "");
	string dbg = input;
	string result = input;
	string hour_s;
	string min_s;
	bool isValid = false;
	int hour;
	int mins;
	int found;
	int length;

	found = input.find("pm");
	if (found != string::npos){
		result = input.substr(0, found);
	}
	found = result.find("am");
	if (found != string::npos){
		result = result.substr(0, found);
	}

	found = result.find_first_of(":");
	if (found != string::npos){
		hour_s = result.substr(0, found);
		hour = atoi(hour_s.c_str());
		//getting min
		length = result.length();
		min_s = result.substr(found, length - 1);
		mins = atoi(min_s.c_str());
		if (hour >= 0 && hour < 24 && mins >= 0 && mins < 60){
			isValid = true;
		}
	}
	else{
		//attempt to convert string to hour in case: 5pm as input
		if (result.length() < 3){
			hour = atoi(result.c_str());
			mins = 0;
			isValid = true;
		}
	}

	return isValid;
}

DateTime::DAY DateTime::GetDayEnum(string input){
	if (input == DATETYPE_SUNDAY1 || input == DATETYPE_SUNDAY2
		|| input == DATETYPE_SUNDAY3 || input == DATETYPE_SUNDAY4){
		return DAY::SUNDAY;
	}
	if (input == DATETYPE_MONDAY1 || input == DATETYPE_MONDAY2
		|| input == DATETYPE_MONDAY3 || input == DATETYPE_MONDAY4){
		return DAY::MONDAY;
	}
	if (input == DATETYPE_TUESDAY1 || input == DATETYPE_TUESDAY2
		|| input == DATETYPE_TUESDAY3 || input == DATETYPE_TUESDAY4){
		return DAY::TUESDAY;
	}
	if (input == DATETYPE_WEDNESDAY1 || input == DATETYPE_WEDNESDAY2
		|| input == DATETYPE_WEDNESDAY3 || input == DATETYPE_WEDNESDAY4){
		return DAY::WEDNESDAY;
	}
	if (input == DATETYPE_THURSDAY1 || input == DATETYPE_THURSDAY2
		|| input == DATETYPE_THURSDAY3 || input == DATETYPE_THURSDAY4){
		return DAY::THURSDAY;
	}
	if (input == DATETYPE_FRIDAY1 || input == DATETYPE_FRIDAY2
		|| input == DATETYPE_FRIDAY3 || input == DATETYPE_FRIDAY4){
		return DAY::FRIDAY;
	}
	if (input == DATETYPE_SATURDAY1 || input == DATETYPE_SATURDAY2
		|| input == DATETYPE_SATURDAY3 || input == DATETYPE_SATURDAY4){
		return DAY::SATURDAY;
	}
	if (input == DATETYPE_TODAY1){
		return GetToday();
	}
	if (input == DATETYPE_TOMORROW1 || input == DATETYPE_TOMORROW2){
		return GetTomorrow();
	}
	return DAY::INVALID;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp
	 */

string DateTime::GetMonthName(int input){
	if (input < 1 || input>12){
		throw std::invalid_argument("received value out of range");
	}


	try{
		switch (input){
		case 1:{
			return _MONTH_JANUARY;
			break;
		}
		case 2:{
			return _MONTH_FEBRUARY;
			break;
		}
		case 3:{
			return _MONTH_MARCH;
			break;
		}
		case 4:{
			return _MONTH_APRIL;
			break;
		}
		case 5:{
			return _MONTH_MAY;
			break;
		}
		case 6:{
			return _MONTH_JUNE;
			break;
		}
		case 7:{
			return _MONTH_JULY;
			break;
		}
		case 8:{
			return _MONTH_AUGUST;
			break;
		}
		case 9:{
			return _MONTH_SEPTEMBER;
			break;
		}
		case 10:{
			return _MONTH_OCTOBER;
			break;
		}
		case 11:{
			return _MONTH_NOVEMBER;
			break;
		}
		case 12:{
			return _MONTH_DECEMBER;
			break;
		}

		default:{
			return _MONTH_JANUARY;
		}
		}
	}
	catch (const std::invalid_argument& e){
		cout << "exception occur" << endl;


	}
}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp
	 */

DateTime::DAY DateTime::GetToday(){
	time_t now = time(0);
	struct tm timeinfo;
	localtime_s(&timeinfo, &now);
	int day = timeinfo.tm_wday;
	switch (day){
	case DAY::SUNDAY:{
		return DAY::SUNDAY;
	}
	case DAY::MONDAY:{
		return DAY::MONDAY;
	}
	case DAY::TUESDAY:{
		return DAY::TUESDAY;
	}
	case DAY::WEDNESDAY:{
		return DAY::WEDNESDAY;
	}
	case DAY::THURSDAY:{
		return DAY::THURSDAY;
	}
	case DAY::FRIDAY:{
		return DAY::FRIDAY;
	}
	case DAY::SATURDAY:{
		return DAY::SATURDAY;
	}
	default:{
		return DAY::INVALID;
	}
	}
	assert(false && "in DateTime::GetToday function");
}

DateTime::DAY DateTime::GetTomorrow(){
	time_t now = time(0);
	struct tm timeinfo;
	localtime_s(&timeinfo, &now);
	int day = timeinfo.tm_wday;
	switch (day){
	case DAY::SUNDAY:{
		return DAY::MONDAY;
	}
	case DAY::MONDAY:{
		return DAY::TUESDAY;
	}
	case DAY::TUESDAY:{
		return DAY::WEDNESDAY;
	}
	case DAY::WEDNESDAY:{
		return DAY::THURSDAY;
	}
	case DAY::THURSDAY:{
		return DAY::FRIDAY;
	}
	case DAY::FRIDAY:{
		return DAY::SATURDAY;
	}
	case DAY::SATURDAY:{
		return DAY::SUNDAY;
	}
	default:{
		return DAY::INVALID;
	}
	}
	assert(false && "in DateTime::GetTomorrow function");
}

string DateTime::Now(){
	time_t now = time(0);
	struct tm timeinfo;
	localtime_s(&timeinfo, &now);
	char output[80];
	strftime(output, 80, "%I:%M%p", &timeinfo);
	return output;
}

string DateTime::Today(){
	time_t now = time(0);
	struct tm timeinfo;
	localtime_s(&timeinfo, &now);
	char output[80];
	strftime(output, 80, "%d/%m/%Y", &timeinfo);
	return output;
}

string DateTime::Tomorrow(){
	time_t currentTime = time(0);
	time_t tomorrow = currentTime + 24 * 60 * 60;
	struct tm timeinfo;
	localtime_s(&timeinfo, &tomorrow);
	char output[80];
	strftime(output, 80, "%d/%m/%Y", &timeinfo);
	return output;
}

bool DateTime::CompareDateTime(string input1, string input2){
	bool isGreater = true;
	Smartstring input_1(input1);
	vector<string> tokens1 = input_1.Tokenize(" ");
	int size1 = tokens1.size();

	Smartstring input_2(input2);
	vector<string> tokens2 = input_2.Tokenize(" ");
	int size2 = tokens2.size();


	switch (size1){
	case 1:{
		if (IsValidDate(tokens1[0])){
			if (IsValidTime(tokens2[0])){
				isGreater = false;
			}
			else if (IsValidDate(tokens2[0])){
				isGreater = CompareDate(tokens1[0], tokens2[0]);
			}
		}

		if (IsValidTime(tokens1[0])){
			if (IsValidTime(tokens2[0])){
				isGreater = CompareTime(tokens1[0], tokens2[0]);
			}

		}

		break;
	}

	case 3:{
		if (size2 == 1){
			if (IsValidTime(tokens2[0])){
				isGreater = CompareTime(tokens1[0], tokens2[0]);
			}
			else if (IsValidDate(tokens2[0])){
				isGreater = CompareDate(tokens1[2], tokens2[0]);
			}
		}

		if (size2 == 3){
			if (!CompareDate(tokens1[2], tokens2[2])){
				isGreater = false;
			}
			else if (tokens1[2] == tokens2[2]){
				isGreater = CompareTime(tokens1[0], tokens2[0]);
			}
		}
		break;
	}

	default:
		break;
	}


	return isGreater;
}

bool DateTime::CompareDate(string date1, string date2){
	int day1, day2;
	int mon1, mon2;
	int year1, year2;
	int length;
	string day_s, mon_s, year_s;
	size_t start, end;
	bool isGreater = true;

	// tokenize first string date 
	start = 0;
	end = date1.find_first_of("/");
	day_s = date1.substr(start, end - start);
	day1 = atoi(day_s.c_str());

	start = end + 1;
	end = date1.find_first_of("/", start);
	mon_s = date1.substr(start, end - start);
	mon1 = atoi(mon_s.c_str());

	start = end + 1;
	length = date1.length();
	year_s = date1.substr(start, length - start);
	year1 = atoi(mon_s.c_str());


	//tokenize second string date

	start = 0;
	end = date1.find_first_of("/");
	day_s = date2.substr(start, end - start);
	day2 = atoi(day_s.c_str());

	start = end + 1;
	end = date2.find_first_of("/", start);
	mon_s = date2.substr(start, end - start);
	mon2 = atoi(mon_s.c_str());

	start = end + 1;
	length = date2.length();
	year_s = date2.substr(start, length - start);
	year2 = atoi(mon_s.c_str());

	//compare
	if (year1 == year2){
		if (mon1 == mon2){
			if (day1 < day2){
				isGreater = false;
			}
		}
		else if (mon1 < mon2){
			isGreater = false;
		}
	}
	else if (year1 < year2){
		isGreater = false;
	}



	return isGreater;
}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp
	 */

bool DateTime::CompareTime(string time1, string time2){
	int hour1, hour2;
	int min1, min2;
	int length;
	string hour_s;
	string min_s;
	size_t found;
	bool isGreater = true;


	found = time1.find_first_of(":");
	hour_s = time1.substr(0, found);
	hour1 = atoi(hour_s.c_str());
	length = time1.length();
	min_s = time1.substr(found + 1, length);
	min1 = atoi(min_s.c_str());

	found = time2.find_first_of(":");
	hour_s = time2.substr(0, found);
	hour2 = atoi(hour_s.c_str());
	length = time2.length();
	min_s = time2.substr(found + 1, length);
	min2 = atoi(min_s.c_str());

	if (hour1 == hour2){
		if (min1 < min2){
			isGreater = false;
		}
	}

	if (hour1 < hour2){
		isGreater = false;
	}

	return isGreater;
}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp
	 */

void DateTime::Initialize(){
	if (!isInitialized){

		dateType.push_back(DATETYPE_MONDAY1);
		dateType.push_back(DATETYPE_MONDAY2);
		dateType.push_back(DATETYPE_MONDAY3);
		dateType.push_back(DATETYPE_MONDAY4);
		dateType.push_back(DATETYPE_TUESDAY1);
		dateType.push_back(DATETYPE_TUESDAY2);
		dateType.push_back(DATETYPE_TUESDAY3);
		dateType.push_back(DATETYPE_TUESDAY4);
		dateType.push_back(DATETYPE_WEDNESDAY1);
		dateType.push_back(DATETYPE_WEDNESDAY2);
		dateType.push_back(DATETYPE_WEDNESDAY4);
		dateType.push_back(DATETYPE_WEDNESDAY3);
		dateType.push_back(DATETYPE_THURSDAY1);
		dateType.push_back(DATETYPE_THURSDAY2);
		dateType.push_back(DATETYPE_THURSDAY3);
		dateType.push_back(DATETYPE_THURSDAY4);
		dateType.push_back(DATETYPE_FRIDAY1);
		dateType.push_back(DATETYPE_FRIDAY2);
		dateType.push_back(DATETYPE_FRIDAY3);
		dateType.push_back(DATETYPE_FRIDAY4);
		dateType.push_back(DATETYPE_SATURDAY1);
		dateType.push_back(DATETYPE_SATURDAY2);
		dateType.push_back(DATETYPE_SATURDAY3);
		dateType.push_back(DATETYPE_SATURDAY4);
		dateType.push_back(DATETYPE_SUNDAY1);
		dateType.push_back(DATETYPE_SUNDAY2);
		dateType.push_back(DATETYPE_SUNDAY3);
		dateType.push_back(DATETYPE_SUNDAY4);
		dateType.push_back(DATETYPE_TODAY1);
		dateType.push_back(DATETYPE_TOMORROW1);
		dateType.push_back(DATETYPE_TOMORROW2);
		timeType.push_back(TIMETYPE_AM);
		timeType.push_back(TIMETYPE_PM);

		numberOfDateType = dateType.size();
		numberOfTimeType = timeType.size();
		isInitialized = true;
	}

}




	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.h
	 */

#pragma once
#include <iostream>
#include <string>
#include <vector>
#include <time.h>
#include <cassert>
#include <iomanip>
#include <exception>
#include "Smartstring.h"
#include "assert.h"

using namespace std;
class DateTime
{

private:
	int _day;
	int _month;
	int _year;
	int _hours;
	int _mins;
	string _period;

	static bool isInitialized;
	static int numberOfDateType;
	static int numberOfTimeType;

	static vector<string> dateType;
	static vector<string> timeType;

	static const string DATETYPE_MONDAY1;
	static const string DATETYPE_MONDAY2;
	static const string DATETYPE_MONDAY3;
	static const string DATETYPE_MONDAY4;
	static const string DATETYPE_TUESDAY1;
	static const string DATETYPE_TUESDAY2;
	static const string DATETYPE_TUESDAY3;
	static const string DATETYPE_TUESDAY4;
	static const string DATETYPE_WEDNESDAY1;
	static const string DATETYPE_WEDNESDAY2;
	static const string DATETYPE_WEDNESDAY3;
	static const string DATETYPE_WEDNESDAY4;
	static const string DATETYPE_THURSDAY1;
	static const string DATETYPE_THURSDAY2;
	static const string DATETYPE_THURSDAY3;
	static const string DATETYPE_THURSDAY4;
	static const string DATETYPE_FRIDAY1;
	static const string DATETYPE_FRIDAY2;
	static const string DATETYPE_FRIDAY3;
	static const string DATETYPE_FRIDAY4;
	static const string DATETYPE_SATURDAY1;
	static const string DATETYPE_SATURDAY2;
	static const string DATETYPE_SATURDAY3;
	static const string DATETYPE_SATURDAY4;
	static const string DATETYPE_SUNDAY1;
	static const string DATETYPE_SUNDAY2;
	static const string DATETYPE_SUNDAY3;
	static const string DATETYPE_SUNDAY4;
	static const string DATETYPE_TODAY1;
	static const string DATETYPE_TOMORROW1;
	static const string DATETYPE_TOMORROW2;
	static const string _MONTH_JANUARY;
	static const string _MONTH_FEBRUARY;
	static const string _MONTH_MARCH;
	static const string _MONTH_APRIL;
	static const string _MONTH_MAY;
	static const string _MONTH_JUNE;
	static const string _MONTH_JULY;
	static const string _MONTH_AUGUST;
	static const string _MONTH_SEPTEMBER;
	static const string _MONTH_OCTOBER;
	static const string _MONTH_NOVEMBER;
	static const string _MONTH_DECEMBER;



	static const string TIMETYPE_AM;
	static const string TIMETYPE_PM;

	enum DATEKEY{ TODAY, TOMORROW };
	enum DAY{ SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, INVALID };

	//methods
	void SetDefaultDateTime();
	void SetStandards();
	void SetSeconds();

	string StandardizeSingle(string);
	string StandardizeTriple(vector<string>);
	string StandardizeDayDate(string); //Standardize input assuming that it is either a day, or a date
	string StandardizeDate(string); //Standardize input assuming that it is a date
	string StandardizeDay(string); //Standardize input assuming that it is a day
	string StandardizeTime(string);
	string TwentyFourHourFormat();// this method returns time in 24 hour format

	bool IsValidDayDate(string); //Check if input is a valid day or date
	bool IsValidDate(string); //Check if input is a valid date
	bool IsValidDay(string); //Check if input is a valid day
	bool IsValidTime(string); //Check if input is a valid time


	DAY GetDayEnum(string); //Gets the DAY in enum format of an input string. i.e. sunday = 0, monday = 1...
	DAY GetTomorrow();
	DAY GetToday();
	string GetMonthName(int); //converts month to string
	int CalculateOffset(DAY, DAY); //Gets the offset for the next occurance of endday based on startday.

	string GetDayFromTime(time_t);
	string GetStandardDate(time_t);
	string GetStandardTime(time_t);
	time_t OffsetByDay(time_t, time_t); //given a startday and number of days to offset by, converts to a time_t value





public:
	string unformattedDateTime;
	string formattedDateTime;
	bool isValidFormat;
	bool isDateSet;
	bool isTimeSet;
	time_t time_in_seconds;

	DateTime();
	DateTime(string);
	~DateTime();

	string Now();
	string Today();
	string Tomorrow();
	string Standardized();
	string GetInfo();
	string GetDate();
	string GetDateWithoutYear();//omit the year if the date&time is in the current year
	string GetTime();
	int GetSeconds();
	bool IsEarlierThan(DateTime);
	bool CompareDateTime(string, string);
	bool CompareDate(string, string);
	bool CompareTime(string, string);
	DateTime* GetDefaultEndDate();
	void Initialize();





};


	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.h





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Parser.cpp
	 */

string Parser::RemoveCommand(string input){
	string command; 
	string userInput;
	string remainder = "";
	istringstream in(input);

	if (in >> command){
		if (getline(in, userInput)){
			int endIdx = userInput.length() - 1;
			remainder = userInput.substr(1, endIdx); //remove white space
		}
	}
	
	return remainder;
	
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Parser.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Parser.cpp
	 */

string Parser::RemoveKeywords(string input){
	istringstream in(input);

	Smartstring userInput;
	string remainder;
	while (in >> userInput){
		if (!userInput.IsKeyword()){
			remainder = userInput.ToString() + " ";
		}
	}
	int endIdx = remainder.length() - 1;
	remainder = remainder.substr(0, endIdx - 1); // remove white space at the end

	return remainder;
}


	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Parser.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Parser.cpp
	 */

vector<string> Parser::Tokenize(string input){
	istringstream in(input);
	vector<string> infos;
	string token;

	while (in >> token){
		infos.push_back(token);
	}

	return infos;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Parser.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Smartstring.cpp
	 */

#include "Smartstring.h"
#include <iostream>


const string Smartstring::COMMAND_ARCHIVED = "archived";
const string Smartstring::COMMAND_ADD = "add";
const string Smartstring::COMMAND_CLEAR = "clear";
const string Smartstring::COMMAND_COMPLETE = "complete";
const string Smartstring::COMMAND_DELETE = "delete";
const string Smartstring::COMMAND_DISPLAY = "display";
const string Smartstring::COMMAND_EDIT = "edit";
const string Smartstring::COMMAND_EMPTYSLOTS = "free";
const string Smartstring::COMMAND_LOAD = "load";
const string Smartstring::COMMAND_UNDO = "undo";
const string Smartstring::COMMAND_SAVE = "save";
const string Smartstring::COMMAND_SEARCH = "search";

const string Smartstring::KEYWORD_ENDDATE_1 = "date:";
const string Smartstring::KEYWORD_ENDDATE_2 = "by:";
const string Smartstring::KEYWORD_ENDDATE_3 = "e:";
const string Smartstring::KEYWORD_ENDDATE_4 = "end:";
const string Smartstring::KEYWORD_ENDDATE_5 = "t:";
const string Smartstring::KEYWORD_ENDDATE_6 = "to:";
const string Smartstring::KEYWORD_ENDDATE_7 = "till:";
const string Smartstring::KEYWORD_ENDDATE_8 = "deadline:";
const string Smartstring::KEYWORD_ENDDATE_9 = "d:";
const string Smartstring::KEYWORD_ENDDATE_10 = "before:";
const string Smartstring::KEYWORD_ENDDATE_11 = "deadline:";
const string Smartstring::KEYWORD_ENDDATE_12 = "due:";
const string Smartstring::KEYWORD_PRIORITY_1 = "priority:";
const string Smartstring::KEYWORD_PRIORITY_2 = "p:";
const string Smartstring::KEYWORD_STARTDATE_1 = "f:";
const string Smartstring::KEYWORD_STARTDATE_2 = "from:";
const string Smartstring::KEYWORD_STARTDATE_3 = "s:";
const string Smartstring::KEYWORD_STARTDATE_4 = "start:";
const string Smartstring::KEYWORD_STARTDATE_5 = "on:";
const string Smartstring::KEYWORD_STARTDATE_6 = "at:";
const string Smartstring::KEYWORD_STARTDATE_7 = "d:";
const string Smartstring::KEYWORD_DESCRIPTION_1 = "description:";
const string Smartstring::KEYWORD_TIMED_1 = "timed:";
const string Smartstring::KEYWORD_DEADLINE_1 = "deadline:";
const string Smartstring::KEYWORD_FLOAT_1 = "float:";


const string Smartstring::FEEDBACK_ADD_SUCCESSULLY = "add the entry successfully";
const string Smartstring::FEEDBACK_DELETE_SUCCESSFULLY = "delete the entry successfully";
const string Smartstring::FEEDBACK_DELETE_FAIL = "fail to delete the entry";
const string Smartstring::FEEDBACK_EDIT_SUCCESSFULLY = "edit the entry successfully";
const string Smartstring::FEEDBACK_EDIT_FAIL = "fail to edit the entry";
const string Smartstring::FEEDBACK_SEARCH_FAIL = "cannot find";


bool Smartstring::isInitialized = false;
int Smartstring::numberOfCommands;
int Smartstring::numberOfKeywords;
const int Smartstring::NUMBER_OF_FIELDS = 5;
vector<string> Smartstring::commands;
vector<string> Smartstring::keywords;

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Smartstring.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Smartstring.cpp
	 */

Smartstring::Smartstring(){
	information = "";
	Initialize();

}


Smartstring::Smartstring(string input){
	information = input;
	Initialize();
}

Smartstring::~Smartstring()
{
}

//this method identifies the type of command user put in 
Smartstring::COMMAND Smartstring::Command(){
	if (information == COMMAND_ARCHIVED){
		return Smartstring::COMMAND::ARCHIVED;
	}

	if (information == COMMAND_ADD){
		return Smartstring::COMMAND::ADD;
	}

	if (information == COMMAND_CLEAR){
		return Smartstring::COMMAND::CLEAR;
	}

	if (information == COMMAND_COMPLETE){
		return Smartstring::COMMAND::COMPLETE;
	}

	if (information == COMMAND_DELETE){
		return Smartstring::COMMAND::DELETE;
	}

	if (information == COMMAND_DISPLAY){
		return Smartstring::COMMAND::DISPLAY;
	}
	if (information == COMMAND_EDIT){
		return Smartstring::COMMAND::EDIT;
	}

	if (information == COMMAND_EMPTYSLOTS){
		return Smartstring::COMMAND::FREE;
	}

	if (information == COMMAND_LOAD){
		return Smartstring::COMMAND::LOAD;
	}

	if (information == COMMAND_UNDO){
		return Smartstring::COMMAND::UNDO;
	}

	if (information == COMMAND_SEARCH){
		return Smartstring::COMMAND::SEARCH;
	}

	if (information == COMMAND_SAVE){
		return Smartstring::COMMAND::SAVE;
	}

	assert(!IsCommand()); //takes care of the case when we add cases to field but did not update static list commands[];
	return Smartstring::COMMAND::INVALID_CMD;
}

//this method identifies the keywords that help to recoginize date and time
Smartstring::FIELD Smartstring::Field(){
	if (information == KEYWORD_STARTDATE_1 || information == KEYWORD_STARTDATE_2
		|| information == KEYWORD_STARTDATE_3 || information == KEYWORD_STARTDATE_4
		|| information == KEYWORD_STARTDATE_5 || information == KEYWORD_STARTDATE_6
		|| information == KEYWORD_STARTDATE_7){

		return Smartstring::FIELD::STARTDATE;
	}

	if (information == KEYWORD_PRIORITY_1 || information == KEYWORD_PRIORITY_2){
		return Smartstring::FIELD::PRIORITY;
	}

	if (information == KEYWORD_ENDDATE_1 || information == KEYWORD_ENDDATE_2
		|| information == KEYWORD_ENDDATE_3 || information == KEYWORD_ENDDATE_4
		|| information == KEYWORD_ENDDATE_5 || information == KEYWORD_ENDDATE_6
		|| information == KEYWORD_ENDDATE_7 || information == KEYWORD_ENDDATE_8
		|| information == KEYWORD_ENDDATE_9 || information == KEYWORD_ENDDATE_10
		|| information == KEYWORD_ENDDATE_11 || information == KEYWORD_ENDDATE_12){

		return Smartstring::FIELD::ENDDATE;
	}

	if (information == KEYWORD_DESCRIPTION_1){
		return Smartstring::FIELD::DESCRIPTION;
	}

	assert(!IsKeyword());
	return Smartstring::FIELD::INVALID_FLD;
}

void Smartstring::Initialize(){
	if (!isInitialized){
		commands.push_back(COMMAND_ARCHIVED);
		commands.push_back(COMMAND_ADD);
		commands.push_back(COMMAND_CLEAR);
		commands.push_back(COMMAND_COMPLETE);
		commands.push_back(COMMAND_DELETE);
		commands.push_back(COMMAND_DISPLAY);
		commands.push_back(COMMAND_EDIT);
		commands.push_back(COMMAND_EMPTYSLOTS);
		commands.push_back(COMMAND_LOAD);
		commands.push_back(COMMAND_UNDO);
		commands.push_back(COMMAND_SAVE);
		commands.push_back(COMMAND_SEARCH);


		keywords.push_back(KEYWORD_ENDDATE_1);
		keywords.push_back(KEYWORD_ENDDATE_2);
		keywords.push_back(KEYWORD_ENDDATE_3);
		keywords.push_back(KEYWORD_ENDDATE_4);
		keywords.push_back(KEYWORD_ENDDATE_5);
		keywords.push_back(KEYWORD_ENDDATE_6);
		keywords.push_back(KEYWORD_ENDDATE_7);
		keywords.push_back(KEYWORD_ENDDATE_8);
		keywords.push_back(KEYWORD_ENDDATE_9);
		keywords.push_back(KEYWORD_ENDDATE_10);
		keywords.push_back(KEYWORD_ENDDATE_11);
		keywords.push_back(KEYWORD_ENDDATE_12);
		keywords.push_back(KEYWORD_PRIORITY_1);
		keywords.push_back(KEYWORD_PRIORITY_2);
		keywords.push_back(KEYWORD_STARTDATE_1);
		keywords.push_back(KEYWORD_STARTDATE_2);
		keywords.push_back(KEYWORD_STARTDATE_3);
		keywords.push_back(KEYWORD_STARTDATE_4);
		keywords.push_back(KEYWORD_STARTDATE_5);
		keywords.push_back(KEYWORD_STARTDATE_6);
		keywords.push_back(KEYWORD_STARTDATE_7);
		keywords.push_back(KEYWORD_DESCRIPTION_1);

		numberOfCommands = commands.size();
		numberOfKeywords = keywords.size();
		isInitialized = true;

		assert(numberOfCommands != 0);
		assert(numberOfKeywords != 0);
	}

	return;
}


bool Smartstring::IsCommand(){
	bool isCommand = false;

	for (int i = 0; i < numberOfCommands; ++i){
		if (information == commands[i]){
			isCommand = true;
		}
	}

	return isCommand;
}

bool Smartstring::IsKeyword(){
	bool isKeyword = false;
	for (int i = 0; i < numberOfKeywords; ++i){
		if (information == keywords[i]){
			isKeyword = true;
		}
	}

	return isKeyword;
}


Smartstring::LIST Smartstring::ListType(){
	if (information == KEYWORD_TIMED_1){
		return Smartstring::LIST::TIMED;
	}
	if (information == KEYWORD_DEADLINE_1){
		return Smartstring::LIST::DEADLINE;
	}
	if (information == KEYWORD_FLOAT_1){
		return Smartstring::LIST::FLOAT;
	}
	return Smartstring::LIST::DEFAULT;
}



string Smartstring::ToString(){
	return information;
}

vector<string> Smartstring::Tokenize(string delimiters){
	int startIdx = 0;
	int endIdx = 0;
	string piece;
	vector<string> tokens;

	while (endIdx != string::npos){
		endIdx = information.find_first_of(delimiters.c_str(), startIdx);
		piece = information.substr(startIdx, endIdx - startIdx);

		if (piece.length() != 0){
			assert(piece.length() != 0);
			tokens.push_back(piece);
		}
		startIdx = endIdx + 1;
	}
	return tokens;
}

vector<string> Smartstring::ContainedTokenize(string delimiters){
	string input = information;
	string piece;
	int found = 0;
	int startFrame = 0;
	int endFrame = 0;
	int startIdx = 0;
	int endIdx = 0;
	vector<string> tokens;

	while (startFrame != string::npos && endFrame != string::npos){
		startFrame = input.find_first_of(delimiters.c_str(), startIdx);

		if (startFrame != string::npos){
			endFrame = input.find_first_of(delimiters.c_str(), startFrame + 1);
			if (endFrame != string::npos){
				int length = endFrame - startFrame - 1;
				piece = input.substr(startFrame + 1, length);
				tokens.push_back(piece);
			}
		}

		startIdx = endFrame + 1;
	}

	return tokens;
}


//operator overloading
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Smartstring.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Smartstring.h
	 */

#pragma once
#include <sstream>
#include <string>
#include <vector>
#include <cassert>
#include <exception>
#include "Logger.h"
#include "assert.h"


using namespace std;
class Smartstring
{
private:

public:
	string information;
	enum COMMAND { ARCHIVED, ADD, CLEAR, COMPLETE, DELETE, DISPLAY, EDIT, FREE, LOAD, UNDO, SAVE, SEARCH, HELP, INVALID_CMD };
	enum FIELD { DESCRIPTION, STARTDATE, ENDDATE, PRIORITY, STATUS, INVALID_FLD };
	enum LIST{ TIMED, DEADLINE, FLOAT, DEFAULT };

	static bool isInitialized;
	static int numberOfCommands;
	static int numberOfKeywords;
	static const int NUMBER_OF_FIELDS;

	static vector<string> commands;
	static vector<string> keywords;

	static const string COMMAND_ARCHIVED;
	static const string COMMAND_ADD;
	static const string COMMAND_CLEAR;
	static const string COMMAND_COMPLETE;
	static const string COMMAND_DELETE;
	static const string COMMAND_DISPLAY;
	static const string COMMAND_EDIT;
	static const string COMMAND_EMPTYSLOTS;
	static const string COMMAND_LOAD;
	static const string COMMAND_UNDO;
	static const string COMMAND_SAVE;
	static const string COMMAND_SEARCH;
	static const string COMMAND_HELP;


	static const string KEYWORD_ENDDATE_1;
	static const string KEYWORD_ENDDATE_2;
	static const string KEYWORD_ENDDATE_3;
	static const string KEYWORD_ENDDATE_4;
	static const string KEYWORD_ENDDATE_5;
	static const string KEYWORD_ENDDATE_6;
	static const string KEYWORD_ENDDATE_7;
	static const string KEYWORD_ENDDATE_8;
	static const string KEYWORD_ENDDATE_9;
	static const string KEYWORD_ENDDATE_10;
	static const string KEYWORD_ENDDATE_11;
	static const string KEYWORD_ENDDATE_12;
	static const string KEYWORD_PRIORITY_1;
	static const string KEYWORD_PRIORITY_2;
	static const string KEYWORD_STARTDATE_1;
	static const string KEYWORD_STARTDATE_2;
	static const string KEYWORD_STARTDATE_3;
	static const string KEYWORD_STARTDATE_4;
	static const string KEYWORD_STARTDATE_5;
	static const string KEYWORD_STARTDATE_6;
	static const string KEYWORD_STARTDATE_7;
	static const string KEYWORD_DESCRIPTION_1;
	static const string KEYWORD_TIMED_1;
	static const string KEYWORD_DEADLINE_1;
	static const string KEYWORD_FLOAT_1;

	static const string FEEDBACK_SEARCH_FAIL;
	static const string FEEDBACK_ADD_SUCCESSULLY;
	static const string FEEDBACK_DELETE_SUCCESSFULLY;
	static const string FEEDBACK_DELETE_FAIL;
	static const string FEEDBACK_EDIT_SUCCESSFULLY;
	static const string FEEDBACK_EDIT_FAIL;

	Smartstring();
	Smartstring(string input);
	~Smartstring();

	//methods
	COMMAND Command();
	FIELD Field();
	void Initialize();
	bool IsCommand();
	bool IsKeyword();
	LIST ListType();
	string ToString();
	vector<string> Tokenize(string delimiters);
	vector<string> ContainedTokenize(string delimiters);

	//operators
	friend istream& operator>>(istream& is, Smartstring& ss);
	friend ostream& operator<< (ostream& os, Smartstring& ss);
	friend string& operator+ (string input, Smartstring &ss);
	friend string& operator+ (Smartstring& ss, string& input);
	friend string& operator+ (const char* s, Smartstring &ss);
	friend string& operator+ (Smartstring &ss, const char* s);


};

istream& operator>>(istream& is, Smartstring& ss);
ostream& operator<<(ostream& os, Smartstring& ss);
string& operator+ (string input, Smartstring& ss);
string& operator+ (Smartstring& ss, string& input);
string& operator+ (const char* s, Smartstring &ss);
string& operator+ (Smartstring &ss, const char* s);



	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Smartstring.h





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

			date1 = "07/07/2015";
			date2 = "06/08/2014";
			dt1 = DateTime(date1);
			dt2 = DateTime(date2);
			Assert::IsFalse(dt1.IsEarlierThan(dt2));
			//testing case
			date1 = "01/09/2014 at 6pm";
			date2 = "06/08/2014 at 7pm";
			dt1 = DateTime(date1);
			dt2 = DateTime(date2);
			Assert::IsFalse(dt1.IsEarlierThan(dt2));
		}

		TEST_METHOD(DATETIME_ISVALIDFORMAT){
			string date;
			DateTime dt;

			//testing the partition input is valid
			date = "07/04/2014";
			dt = DateTime(date);
			Assert::IsTrue(dt.isValidFormat);

			//testing the partition where input is not valid
			date = "owkdowkdow";
			dt = DateTime(date);
			Assert::AreEqual(dt.Standardized(), date);
			Assert::IsFalse(dt.isValidFormat);
		}

		TEST_METHOD(DATETIME_INVALIDINPUTS_UNCHANGED){
			string date;
			DateTime dt;
			date = "owkdowkdowdkowdww";
			dt = DateTime(date);
			Assert::AreEqual(dt.Standardized(), date);
		}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(SMARTSTRING_ISCOMMAND){
			//test for true case
			Smartstring test1("add");
			bool isCommand_Expected;
			bool isCommand_Actual;

			isCommand_Expected = true;
			isCommand_Actual = test1.IsCommand();

			Assert::AreEqual(isCommand_Expected, isCommand_Actual);

			// test for false case
			Smartstring test2("dhiwihwie");

			isCommand_Expected = false;
			isCommand_Actual = test2.IsCommand();

			Assert::AreEqual(isCommand_Expected, isCommand_Actual);
		}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(SMARTSTRING_ISKEYWORD){
			bool isKeyword_Expected;
			bool isKeyword_Actual;

			//test for true case
			Smartstring test1("due:");
			isKeyword_Expected = true;
			isKeyword_Actual = test1.IsKeyword();

			Assert::AreEqual(isKeyword_Expected, isKeyword_Actual);

			//test for false case
			Smartstring test2("due");
			isKeyword_Expected = false;
			isKeyword_Actual = test2.IsKeyword();

			Assert::AreEqual(isKeyword_Expected, isKeyword_Actual);
	
		}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(DATETIME_COMPAREDATE){
			bool expected;
			bool actual;

			DateTime test1;

			//test for same day 
			Assert::AreEqual(true, test1.CompareDate("10/6/2015", "10/5/2015"));
			//same day and month
			Assert::AreEqual(true, test1.CompareDate("10/6/2015", "10/6/2013"));
		}


	};
}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





