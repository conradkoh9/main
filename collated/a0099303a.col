//@author: a0099303a



	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp
	 */

int DateTime::CalculateOffset(DAY startday, DAY endday){
	int result;

	if (startday > endday){
		result = endday - startday + 7;
	}
	else{
		result = endday - startday;
	}

	return result;
}

string DateTime::GetDayFromTime(time_t time){
	struct tm timeinfo;
	localtime_s(&timeinfo, &time);
	char output[80];
	strftime(output, 80, "%A", &timeinfo);
	return output;
}

string DateTime::GetStandardDate(time_t time){
	struct tm timeinfo;
	localtime_s(&timeinfo, &time);
	char output[80];
	strftime(output, 80, "%d/%m/%Y", &timeinfo);
	return output;
}

string DateTime::GetStandardTime(time_t time){
	struct tm timeinfo;
	localtime_s(&timeinfo, &time);
	char output[80];
	strftime(output, 80, "%I:%M%p", &timeinfo);
	return output;
}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp
	 */

time_t DateTime::OffsetByDay(time_t timeReference, time_t offset_in_days){
	time_t output;
	time_t offset_in_seconds = offset_in_days * 24 * 60 * 60;
	output = timeReference + offset_in_seconds;
	return output;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp
	 */

DateTime* DateTime::GetDefaultEndDate(){
	DateTime* dt = new DateTime();
	*dt = *this;
	dt->_hours++;
	return dt;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\DateTime.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Logger.cpp
	 */

namespace logging{
	Logger::Logger()
	{
	}


	Logger::~Logger()
	{
	}

	string Logger::Write(string input){
		string feedback = "";
		ofstream out;
		DateTime timeinfo;
		out.open(_logfilename.c_str(), ios::app);
		out << "[" << timeinfo.Today() << "] " << "[" << timeinfo.Now() << "]: " << input << endl;
		out.close();
		return feedback;
	}

	Logger& operator<<(Logger& logger, string input){
		logger.Write(input);
		return logger;
	}
}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Logger.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Logger.h
	 */

#include <fstream>
#include <sstream>
#include "DateTime.h";
using namespace std;
namespace logging{
	class Logger
	{
	public:
		Logger();
		~Logger();

	private:
		string _logfilename = "debug.log";
		string Write(string input);
		
		friend Logger& operator<<(Logger& logger, string input);
	};
	static Logger logfile;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Logger.h





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Smartstring.cpp
	 */

ostream& operator<<(ostream& os, Smartstring& ss){
	os << ss.information;
	return os;
}

istream& operator>>(istream& is, Smartstring& ss){
	is >> ss.information;
	return is;
}

string& operator+ (string input, Smartstring& ss){
	return (input + ss.information);
}

string& operator+ (Smartstring& ss, string& input){
	return (ss.information + input);
}

string& operator+ (const char* s, Smartstring &ss){
	string out;
	string first = s;
	out = first + ss.information.c_str();
	return out;
}
string& operator+ (Smartstring &ss, const char* s){
	string out;
	string first = s;
	out = first + ss.information.c_str();
	return out;
}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Smartstring.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */


//====================================================================
//Core Functionality
//====================================================================
Storage::Storage(){
	Load();
	status << _FEEDBACK_STARTUP << _filename;
}

Storage::Storage(string input){
	_filename = input;
	SaveSessionData();
}

Storage::~Storage(){
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::Add(Task* task){
	UpdateUndoVectors();
	string feedback = AddToTaskVector(task);
	Update();
	Rewrite();
	UpdateStatus(feedback);
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::DeleteFromList(int position, Smartstring::LIST list){
	UpdateUndoVectors();
	try{
		Task* toDelete = GetTaskPtr(position, list);
		Erase(toDelete);
		Rewrite();
		Update();
		UpdateStatus(_FEEDBACK_DELETE_SUCCESS);
	}
	catch (InvalidIndex){
		UpdateStatus(_FEEDBACK_INVALID_INDEX);
	}
	catch (InvalidList){
		UpdateStatus(_FEEDBACK_INVALID_LIST);
	}
	return;
}


	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::Delete(int position){

	//Smartstring::LIST list = IdentifyListFromIndex(position);
	try{
		UpdateUndoVectors();
		string feedback = Remove(position);
		Rewrite();
		Update();
		UpdateStatus(feedback);
	}
	catch (out_of_range){
		status << _FEEDBACK_DELETE_FAILURE;
	}
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::Edit(int position, vector<string> newinfo){
	UpdateUndoVectors();
	try{
		Task* taskptr = GetTaskPtr(position);
		Task* newTask = EditToNewTask(*taskptr, newinfo);
		ReplaceTask(taskptr, newTask);
		Rewrite();
		Update();
		UpdateStatus(_FEEDBACK_EDIT_SUCCESS);
		return;
	}

	catch (InvalidIndex){
		UpdateStatus(_FEEDBACK_INVALID_INDEX);
	}
	catch (InvalidList){
		UpdateStatus(_FEEDBACK_INVALID_LIST);
	}
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::Complete(int position){

	try{
		UpdateUndoVectors();
		Task* toremove = GetTaskPtr(position);
		string feedback = MarkComplete(toremove);
		Archive(toremove);
		Rewrite();
		Update();
		UpdateStatus(feedback);
	}
	catch (InvalidIndex){
		UpdateStatus(_FEEDBACK_INVALID_INDEX);
	}
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::Load(){
	LoadSessionData(); //change active file
	FILETYPE filetype = IdentifyFileType(_filename);
	try{
		if (filetype != FILETYPE::INVALID){
			ClearVectors();
			ClearUndoVectors();
			LoadRawFileContent();
			LoadRawArchiveContent();
			LoadTaskList();
			LoadArchiveList();
			Update();
			UpdateStatus(_FEEDBACK_LOAD_SUCCESS);

		}
		else{
			UpdateStatus(_FEEDBACK_FILETYPE_INVALID);
			throw load_failure;
		}
	}
	
	catch (LoadFailure){
		DefaultSession();
		UpdateStatus(_FEEDBACK_LOAD_FAILURE);
	}
	return;

}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::Load(string filename){

	FILETYPE filetype = IdentifyFileType(filename);
	string feedback;
	try{
		if (filetype != FILETYPE::INVALID){
			UpdateFileName(filename);
			ClearVectors();
			ClearUndoVectors();
			LoadRawFileContent();
			LoadTaskList();
			Update();
			UpdateStatus(_FEEDBACK_LOAD_SUCCESS);
		}
		else{
			UpdateStatus(_FEEDBACK_FILETYPE_INVALID);
		}
	}

	catch (LoadFailure){
		DefaultSession();
		UpdateStatus(_FEEDBACK_LOAD_FAILURE);
	}
	return;
}


	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::Save(){
	Rewrite();
	SaveSessionData();
	UpdateStatus(_FEEDBACK_SESSION_SAVE_SUCCESS);
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::SaveAs(string newFileName){
	FILETYPE filetype = IdentifyFileType(newFileName);
	if (filetype!= FILETYPE::INVALID){
		UpdateFileName(newFileName);
		Rewrite();
		SaveSessionData();
		UpdateStatus(_FEEDBACK_SESSION_SAVE_SUCCESS);		
	}
	else{
		UpdateStatus(_FEEDBACK_FILETYPE_INVALID);
	}
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::Rewrite(){
	ClearFile();
	WriteToArchive();
	WriteToFile();
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::Reset(){
	UpdateFileName(_FILENAME_DEFAULT);
	Clear();
	UpdateStatus(_FEEDBACK_RESET);
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::Clear(){
	UpdateUndoVectors();
	ClearFile();
	ClearVectors();
	Update();
	UpdateStatus(_FEEDBACK_CLEAR_SUCCESS);
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

//====================================================================
//ToString methods
//====================================================================

string Storage::Help(){
	ostringstream out;
	out << _MESSAGE_HELP_ADD << endl << endl;
	out << _MESSAGE_HELP_DELETE << endl << endl;
	out << _MESSAGE_HELP_COMPLETE << endl << endl;
	out << _MESSAGE_HELP_EDIT << endl << endl;
	out << _MESSAGE_HELP_UNDO << endl << endl;
	out << _MESSAGE_HELP_LOAD << endl << endl;
	out << _MESSAGE_HELP_SAVEAS << endl << endl;
	out << _MESSAGE_HELP_ARCHIVE << endl << endl;
	out << _MESSAGE_HELP_DISPLAY << endl << endl;
	return out.str();
}
string Storage::GetArchive(){
	Update();
	return ArchiveToString();
}

string Storage::ToString(){
	Update();
	return GetFormattedTaskList();
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::DefaultSession(){
	_filename = _FILENAME_DEFAULT;
	Update();
	status << _FEEDBACK_DEFAULT_SESSION_STARTED;
	return _FEEDBACK_DEFAULT_SESSION_STARTED;
}


//====================================================================
//Update Methods
//====================================================================
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::Update(){
	FilterTask();
	SaveSessionData();
	return;
}

void Storage::UpdateStatus(string status_m){
	status << status_m;
	return;
}

//====================================================================
//Undo Methods
//====================================================================
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */


void Storage::UpdateUndoVectors(){
	lastList = taskList;
	lastArchiveList = archiveList;
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::RestoreFromUndoVectors(){
	taskList = lastList;
	archiveList = lastArchiveList;
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

//====================================================================
//Clear Methods
//====================================================================

string Storage::AddToTaskVector(Task* taskptr){
	taskList.push_back(taskptr);
	return _FEEDBACK_ADD_SUCCESS;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

//====================================================================
//Clear Methods
//====================================================================
void Storage::ClearFile(){
	ofstream out(_filename, ofstream::trunc);
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::ClearFilteredLists(){
	timedList.clear();
	floatingList.clear();
	deadlineList.clear();
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::ClearVectors(){
	taskList.clear();
	timedList.clear();
	floatingList.clear();
	deadlineList.clear();
	_filecontent.clear();
	_archivecontent.clear();
	archiveList.clear();
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::ClearUndoVectors(){
	lastList.clear();
	lastArchiveList.clear();
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::Remove(int position){
	try{
		int size_taskList = taskList.size();
		if (position > size_taskList || position < 1){
			throw invalid_index;
		}
		taskList.erase(taskList.begin() + position - 1);
	}
	catch (InvalidIndex){
		throw invalid_index;
		return _FEEDBACK_DELETE_FAILURE;
	}
	return _FEEDBACK_DELETE_SUCCESS;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::Erase(Task* taskptr){
	vector<Task*>::iterator iter;
	for (iter = taskList.begin(); iter != taskList.end();){
		if (taskptr == (*iter)){
			iter = taskList.erase(iter);
		}
		else{
			++iter;
		}
	}
	return _FEEDBACK_DELETE_SUCCESS;
}


//====================================================================
//Edit methods
//====================================================================
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

Task* Storage::EditToNewTask(Task task, vector<string> newinfo){
	Task* newTask = new Task();
	*newTask = task;
	newTask->Edit(newinfo);
	return newTask;
}

//====================================================================
//Save methods
//====================================================================
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

void Storage::UpdateFileName(string newFileName){
	_filename = newFileName;
	logfile << _LOG_MESSAGE_FILENAME_CHANGED << newFileName;
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::SaveSessionData(){
	ofstream of;
	string feedback;
	of.open(_FILENAME_SESSION_DATA.c_str(), ios::trunc);
	of << _filename;
	of.close();
	ifstream file;
	file.open(_FILENAME_SESSION_DATA.c_str());
	string buffer;
	file >> buffer;
	file.close();
	if (buffer.empty()){
		feedback = _FEEDBACK_SESSION_SAVE_FAILURE;
	}
	else{
		feedback = _FEEDBACK_SESSION_SAVE_SUCCESS + " " + buffer;
	}
	return feedback;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::WriteToFile(){
	FILETYPE filetype = IdentifyFileType(_filename);
	string feedback;
	switch (filetype){
	case(FILETYPE::TXT) : {
		feedback = WriteToTXT();
		break;
	}
	default : {
		UpdateStatus(_FEEDBACK_INVALID_FILE_FORMAT);
		return _FEEDBACK_INVALID_FILE_FORMAT;
		break;
	}
	}
	return feedback;

}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::WriteToTXT(){
	ostringstream out;
	ofstream of;
	of.open(_filename.c_str(), ios::app);
	vector<Task*>::iterator iter;
	for (iter = taskList.begin(); iter != taskList.end(); ++iter){
		if (iter + 1 != taskList.end()){
			out << (*iter)->ToTXTString() << endl;
		}
		else{
			out << (*iter)->ToTXTString();
		}
	}
	of << out.str();

	return _FEEDBACK_WRITE_SUCCESS;
}

string Storage::WriteToArchive(){
	ostringstream out;
	ofstream of;
	of.open(_archivefile.c_str(), ios::trunc);
	vector<Task*>::iterator iter;
	int size = archiveList.size();
	for (iter = archiveList.begin(); iter != archiveList.end(); ++iter){
		out << (*iter)->ToTXTString() << endl;
	}
	of << out.str();
	return _FEEDBACK_WRITE_SUCCESS;
}

//====================================================================
//Load methods
//====================================================================
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::LoadSessionData(){
	ifstream file;
	file.open(_FILENAME_SESSION_DATA);
	getline(file, _filename);
	string feedback;
	if (_filename.empty()){
		feedback = _FEEDBACK_LOAD_FAILURE;
	}
	else{
		feedback = _FEEDBACK_LOAD_SUCCESS;
	}
	logfile << _filename;
	logfile << feedback;

	return feedback;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::LoadRawFileContent(){
	string line;
	vector<string> all_lines;
	ifstream in(_filename.c_str());
	try{
		if (in.is_open()){
			while (getline(in, line)){
				if (line == _EMPTY_STRING){
					return _FEEDBACK_FILE_EMPTY;
				}

				all_lines.push_back(line);
			}
			_filecontent = all_lines;
			return _FEEDBACK_LOAD_SUCCESS;
		}
	}
	catch (out_of_range){
		logfile << _FEEDBACK_LOAD_FAILURE;
		return _FEEDBACK_LOAD_FAILURE;
	}
	return _FEEDBACK_LOAD_FAILURE;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::LoadRawArchiveContent(){
	string line;
	vector<string> all_lines;
	ifstream in(_archivefile.c_str());
	try{
		if (in.is_open()){
			while (getline(in, line)){
				if (line == _EMPTY_STRING){
					return _FEEDBACK_FILE_EMPTY;
				}

				all_lines.push_back(line);
			}
			_archivecontent = all_lines;
			return _FEEDBACK_LOAD_SUCCESS;
		}
	}
	catch (out_of_range){
		logfile << _FEEDBACK_LOAD_FAILURE;
		return _FEEDBACK_LOAD_FAILURE;
	}
	return _FEEDBACK_LOAD_FAILURE;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::LoadTaskList(){
	FILETYPE filetype = IdentifyFileType(_filename);
	string feedback;
	switch (filetype){
		case(FILETYPE::TXT) : {
			feedback = LoadTXTContent();
			break;
		}
		default : {
			logfile << _FEEDBACK_LOAD_FAILURE;
			return _FEEDBACK_LOAD_FAILURE;
			break;
		}
	}
	return feedback;
	
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::LoadArchiveList(){
	FILETYPE filetype = IdentifyFileType(_filename);
		string feedback;
			switch (filetype){
			case(FILETYPE::TXT) : {
				feedback = LoadTXTArchiveContent();
				break;
			}
			default : {
				logfile << _FEEDBACK_LOAD_FAILURE;
				return _FEEDBACK_LOAD_FAILURE;
				break;
		}
	}
	return feedback;

}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::LoadTXTContent(){
	Smartstring str;
	const int startfield = Smartstring::FIELD::DESCRIPTION;
	int currentfield = startfield;
	int fieldcount = Smartstring::NUMBER_OF_FIELDS;
	vector<string>::iterator iter;
	Task* taskptr = new Task();
	//remove field description from _filecontent
	vector<string> taskContent;
	for (iter = _filecontent.begin(); iter != _filecontent.end(); ++iter){
		string line = (*iter);
		istringstream is(line);
		string buffer;
		is >> buffer;
		string output;
		getline(is, output);
		int length = line.length() - 1;
		output = output.substr(1, length);
		taskContent.push_back(output);
	}
	
	//end remove field description from _filecontent
	try{
		for (iter = taskContent.begin(); iter != taskContent.end(); ++iter){
			if (currentfield == Smartstring::FIELD::DESCRIPTION){
				taskptr = new Task();
				taskList.push_back(taskptr);
			}
			switch (currentfield){
			case Smartstring::FIELD::DESCRIPTION:{
				taskptr->SetDescription(*iter);
				break;
			}
			case Smartstring::FIELD::STARTDATE:{
				taskptr->SetStartDateTime(*iter);
				break;
			}
			case Smartstring::FIELD::ENDDATE:{
				taskptr->SetEndDateTime(*iter);
				break;
			}
			case Smartstring::FIELD::PRIORITY:{
				taskptr->SetPriority(*iter);
				break;
			}
			case Smartstring::FIELD::STATUS:{
				taskptr->SetStatus(*iter);
			}

			}
			currentfield = (currentfield + 1) % fieldcount;
		}
	}

	catch (out_of_range){
		logfile << _FEEDBACK_LOAD_FAILURE;
		return _FEEDBACK_LOAD_FAILURE;
	}
	logfile << _FEEDBACK_LOAD_SUCCESS;
	return _FEEDBACK_LOAD_SUCCESS;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::LoadTXTArchiveContent(){
	Smartstring str;
	const int startfield = Smartstring::FIELD::DESCRIPTION;
	int currentfield = startfield;
	int fieldcount = Smartstring::NUMBER_OF_FIELDS;
	vector<string>::iterator iter;
	Task* taskptr = new Task();
	//remove field description from _filecontent
	vector<string> taskContent;
	for (iter = _archivecontent.begin(); iter != _archivecontent.end(); ++iter){
		string line = (*iter);
		istringstream is(line);
		string buffer;
		is >> buffer;
		string output;
		getline(is, output);
		int length = line.length() - 1;
		output = output.substr(1, length);
		taskContent.push_back(output);
	}

	//end remove field description from _filecontent
	try{
		for (iter = taskContent.begin(); iter != taskContent.end(); ++iter){
			if (currentfield == Smartstring::FIELD::DESCRIPTION){
				taskptr = new Task();
				archiveList.push_back(taskptr);
			}
			switch (currentfield){
			case Smartstring::FIELD::DESCRIPTION:{
				taskptr->SetDescription(*iter);
				break;
			}
			case Smartstring::FIELD::STARTDATE:{
				taskptr->SetStartDateTime(*iter);
				break;
			}
			case Smartstring::FIELD::ENDDATE:{
				taskptr->SetEndDateTime(*iter);
				break;
			}
			case Smartstring::FIELD::PRIORITY:{
				taskptr->SetPriority(*iter);
				break;
			}
			case Smartstring::FIELD::STATUS:{
				taskptr->SetStatus(*iter);
			}

			}
			currentfield = (currentfield + 1) % fieldcount;
		}
	}

	catch (out_of_range){
		logfile << _FEEDBACK_LOAD_FAILURE;
		return _FEEDBACK_LOAD_FAILURE;
	}
	logfile << _FEEDBACK_LOAD_SUCCESS;
	return _FEEDBACK_LOAD_SUCCESS;
}



//====================================================================
//Mark methods
//====================================================================
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

string Storage::MarkComplete(Task* taskptr){

	vector<Task*>::iterator iter;
	for (iter = taskList.begin(); iter != taskList.end(); ++iter){
		if (taskptr == (*iter)){
			(*iter)->MarkComplete();
		}
	}

	return _FEEDBACK_UPDATE_SUCCESS;
}

void Storage::Archive(Task* taskptr){
	archiveList.push_back(taskptr);
	Erase(taskptr);
	return;
}

//====================================================================
//File analysis methods
//====================================================================
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

Storage::FILETYPE Storage::IdentifyFileType(string input){
	if (input.find(_FILE_EXTENSION_TXT) != string::npos){
		return FILETYPE::TXT;
	}
	else{
		return FILETYPE::INVALID;
	}

}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

bool Storage::FileEmpty(string filename){
	ifstream ifs;
	ifs.open(filename);
	string test;
	ifs >> test;
	if (test.empty()){
		ifs.close();
		return true;
	}
	else{
		ifs.close();
		return false;
	}
}

//====================================================================
//Get Task* methods
//====================================================================
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

Task* Storage::GetTaskPtr(int position, Smartstring::LIST list){
	Task* taskptr;
	switch (list){
		case Smartstring::LIST::TIMED:{
			taskptr = GetTimedTask(position);
			break;
		}
		case Smartstring::LIST::DEADLINE:{
			taskptr = GetDeadlineTask(position);
			break;
		}
		case Smartstring::LIST::FLOAT:{
			taskptr = GetFloatingTask(position);
			break;
		}

		default:{
			throw invalid_list;
		}
	}
	return taskptr;
}

Task* Storage::GetTaskPtr(int position){
	if (position <= taskList.size() && position > 0){
		return taskList[position - 1];
	}
	else{
		throw invalid_index;
	}
}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

Task* Storage::GetTimedTask(int position){
	int size = timedList.size();
	if (position > size || position < 1){
		throw invalid_index;
	}
	else{
		return timedList[position - 1];
	}
	assert(false && "GetTimedTask failure");
	return NULL;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

Task* Storage::GetDeadlineTask(int position){
	int size = deadlineList.size();
	if (position > size || position < 1){
		throw invalid_index;
	}
	else{
		return deadlineList[position - 1];
	}

	assert(false && "GetDeadlineTask failure");
	return NULL;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

Task* Storage::GetFloatingTask(int position){
	int size = floatingList.size();
	if (position > size || position < 1){
		throw invalid_index;
	}
	else{
		return floatingList[position - 1];
	}

	assert(false && "GetFloatingTask failure");
	return NULL;
}

void Storage::ReplaceTask(Task* taskptr, Task* replacer){
	vector<Task*>::iterator iter;
	for (iter = taskList.begin(); iter != taskList.end(); ++iter){
		if ((*iter) == taskptr){
			(*iter) = replacer;
		}
	}

	return;
}
//====================================================================
//Get Archive Methods
//====================================================================

string Storage::ArchiveToString(){
	ostringstream out;
	int index = 0;
	vector<Task*>::iterator iter;
	if (archiveList.size() != 0){
		for (iter = archiveList.begin(); iter != archiveList.end(); ++iter){
			++index;
			if (iter + 1 != archiveList.end()){
				out << _rtfboldtagstart << index << ": " << _rtfboldtagend << (*iter)->ToShortString() << endl;
			}
			else{
				out << _rtfboldtagstart << index << ": " << _rtfboldtagend << (*iter)->ToShortString();
			}
		}
		status << _FEEDBACK_VIEW_ARCHIVE;
		return out.str();
	}
	else{
		status << _FEEDBACK_ARCHIVE_EMPTY;
		return "";
	}


}

string Storage::GetFormattedTaskList(){
	ostringstream out;
	int index = 0;
	vector<Task*>::iterator iter;
	for (iter = taskList.begin(); iter != taskList.end(); ++iter){
		++index;
		if (iter + 1 != taskList.end()){
			out << _rtfboldtagstart << index << ": " << _rtfboldtagend << (*iter)->ToShortString() << endl;
		}
		else{
			out << _rtfboldtagstart << index << ": " << _rtfboldtagend << (*iter)->ToShortString();
		}
	}
	return out.str();
}

//====================================================================
//Identification of List methods
//====================================================================

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp
	 */

Smartstring::LIST Storage::IdentifyListFromIndex(int index){

	Smartstring::LIST list;
	if (index < deadlineList.size()){
		return Smartstring::LIST::TIMED;
	}
	else{
		if (index > deadlineList.size()){
			return Smartstring::LIST::FLOAT;
		}
		else{
			return Smartstring::LIST::DEADLINE;
		}
	}
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.h
	 */

	//exceptions
	class InvalidIndex : public exception{
	} invalid_index;

	class InvalidList : public exception{

	} invalid_list;

	class InvalidInput : public exception{
	} invalid_input;

	class LoadFailure : public exception{
	} load_failure;

	class FirstRun : public LoadFailure{
	} first_run;

	class CorruptedData : public LoadFailure{
	} corrupted_data;

};



	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Storage.h





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

Task::Task(vector<string> input){

	description = input[Smartstring::FIELD::DESCRIPTION];
	priority = input[Smartstring::FIELD::PRIORITY];
	status = input[Smartstring::FIELD::STATUS];
	standardStartdt = new DateTime(input[Smartstring::FIELD::STARTDATE]);
	standardEnddt = new DateTime(input[Smartstring::FIELD::ENDDATE]);

	startDateTime = standardStartdt->Standardized();
	endDateTime = standardEnddt->Standardized();
	//set default enddate if timed task
	if (startDateTime != "" && endDateTime == "")
	{
		standardEnddt = standardStartdt->GetDefaultEndDate();
		endDateTime = standardEnddt->Standardized();
		enddate = standardEnddt->GetDate();
		endtime = standardStartdt->GetTime();
	}
	//end set default enddate if timed task

	startdate = standardStartdt->GetDateWithoutYear();
	starttime = standardStartdt->GetTime();
	enddate = standardEnddt->GetDateWithoutYear();
	endtime = standardEnddt->GetTime();

	if (status == ""){
		status = _STATUS_INCOMPLETE;
	}

	//this takes care of the cases here the user inputs start at 5pm and end at 6pm but doesn't specify the date
	if (standardStartdt->isTimeSet && !standardStartdt->isDateSet){
		startdate = standardStartdt->GetDateWithoutYear();
		startDateTime = standardStartdt->GetTime() + " on " + standardStartdt->GetDate();
	}
	if (standardEnddt->isTimeSet && !standardEnddt->isDateSet){
		enddate = startdate;
		endDateTime = standardEnddt->GetTime() + " on " + standardStartdt->GetDate();
	}
}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

string Task::Edit(vector<string> newinfo){
	for (int i = 0; i < newinfo.size(); ++i){
		if (newinfo[i] != ""){
			if (newinfo[i] == "-"){
				newinfo[i] = "";
			}
			switch (i){
			case Smartstring::FIELD::DESCRIPTION:{
				SetDescription(newinfo[i]);
				break;
			}
			case Smartstring::FIELD::STARTDATE:{
				SetStartDateTime(newinfo[i]);
				break;
			}
			case Smartstring::FIELD::ENDDATE:{
				SetEndDateTime(newinfo[i]);
				break;
			}
			case Smartstring::FIELD::PRIORITY:{
				SetPriority(newinfo[i]);
				break;
			}
			}
		}
	}
	return ToString();
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

string Task::ToString(){
	ostringstream out;
	out << FIELD_DESCRIPTION << description << endl;
	out << FIELD_STARTDATE << startDateTime << endl;
	out << FIELD_ENDDATE << endDateTime << endl;
	out << FIELD_PRIORITY << priority << endl;
	out << FIELD_STATUS << status;
	return out.str();
}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

string Task::ToShortString(){
	string output = "";
	TASKTYPE tasktype = GetType();
	switch (tasktype){
	case(TASKTYPE::DEADLINE) : {
		output = ToDeadlineString();
		break;
	}
	case(TASKTYPE::FLOATING) : {
		output = ToFloatingString();
		break;
	}
	case(TASKTYPE::TIMED) : {
		output = ToTimedString();
		break;
	}
	default:{
		output = ToTimedString();
		break;
	}
	}
	return output;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

string Task::ToDeadlineString(){
	ostringstream out;
	out << "[" << enddate;
	if (standardEnddt->isTimeSet){
		out << "," << endtime;
	}
	out << "] ";
	out << description;
	return out.str();
}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

string Task::ToFloatingString(){
	ostringstream out;
	out << description;
	return out.str();
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

string Task::ToTimedString(){
	ostringstream out;

	ostringstream startstrm;
	ostringstream endstrm;

	// generate startdate block
	startstrm << "[";
	if (standardStartdt->isValidFormat){

		if (standardStartdt->isTimeSet){
			startstrm << startdate << "," << starttime;
		}
		else{
			startstrm << startdate;
		}

	}
	else{
		startstrm << _rtfcolorredprefix << standardStartdt->Standardized() << _rtfcolorredsuffix;
	}
	startstrm << "]";

	//generate enddate block
	endstrm << "[";
	if (standardEnddt->isValidFormat && standardStartdt->IsEarlierThan(*standardEnddt)){

		if (standardEnddt->isTimeSet){
			endstrm << enddate << "," << endtime;
		}
		else{
			endstrm << enddate;
		}

	}
	else{
		//this section covers all the cases in the else block
		if (standardEnddt->isValidFormat){
			if (standardEnddt->isTimeSet){
				endstrm << _rtfcolorredprefix << enddate << "," << endtime << _rtfcolorredsuffix;
			}
			else{
				endstrm << _rtfcolorredprefix << enddate << _rtfcolorredsuffix;
			}
			
		}
		else{
			endstrm << _rtfcolorredprefix << standardEnddt->Standardized() << _rtfcolorredsuffix;
		}
	}
	endstrm << "] ";

	//generate description
	out << startstrm.str() << endstrm.str() << description;

	return out.str();
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

string Task::ToTXTString(){
	//this to string method is used in storage to write to txt files
	ostringstream out;
	out << FIELD_DESCRIPTION << description << endl;
	out << FIELD_STARTDATE << startDateTime << endl;
	out << FIELD_ENDDATE << endDateTime << endl;
	out << FIELD_PRIORITY << priority << endl;
	out << FIELD_STATUS << status;
	return out.str();
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

string Task::ToCSVString(){
	ostringstream out;
	out << "\"" << description << "\",";
	out << "\"" << startDateTime << "\",";
	out << "\"" << endDateTime << "\",";
	out << "\"" << priority << "\",";
	out << "\"" << status << "\"";
	return out.str();
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

string Task::ToDatelessString(){
	string output = "";
	TASKTYPE tasktype = GetType();
	switch (tasktype){
	case(TASKTYPE::DEADLINE) : {
		output = ToDatelessDeadlineString();
		break;
	}
	case(TASKTYPE::FLOATING) : {
		output = ToDatelessFloatingString();
		break;
	}
	case(TASKTYPE::TIMED) : {
		output = ToDatelessTimedString();
		break;
	}
	default:{
		output = ToDatelessTimedString();
		break;
	}
	}
	return output;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

string Task::ToDatelessDeadlineString(){
	ostringstream out;
	out << description;
	return out.str();
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

string Task::ToDatelessFloatingString(){
	ostringstream out;
	out << description;
	return out.str();
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

string Task::ToDatelessTimedString(){

	ostringstream out;
	out << "[" << enddate;
	if (standardEnddt->isTimeSet){
		out << "," << endtime;
	}
	out << "] ";
	out << description;
	return out.str();
}


	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp
	 */

ostream& operator<<(ostream& out, Task& task){
	out << task.ToString();
	return out;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\Task.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\UI_Controller.cpp
	 */

UI_Controller::UI_Controller()
{
	logic = new Logic();
	UpdateDisplays();
	ClearStreams();
	logfile << "UI Created";
}


UI_Controller::~UI_Controller()
{
}

void UI_Controller::Run(string input){
	logic->Run(input);
	UpdateDisplays();
	ClearStreams();
	return;
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_Schedule\UI_Controller.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleGUI\GUI.h
	 */

	private: System::Void BUTTON_SEND_Click(System::Object^  sender, System::EventArgs^  e) {
		string input = msclr::interop::marshal_as<std::string>(INPUT_CMDLN->Text);
		controller->Run(input);
		//update displays from file
		DISPLAY_TASK_TIMED->LoadFile(gcnew String(controller->rtf_timed.c_str()));
		DISPLAY_TASK_DEADLINE->LoadFile(gcnew String(controller->rtf_deadline.c_str()));
		DISPLAY_TASK_FLOAT->LoadFile(gcnew String(controller->rtf_float.c_str()));
		DISPLAY_MAIN->LoadFile(gcnew String(controller->rtf_main.c_str()));
		//end update displays from file

		//update status bar
		DISPLAY_STATUS->Text = gcnew String(controller->DISPLAY_STATUS.c_str());
		//end update status bar

		//clear the text in command line
		INPUT_CMDLN->Clear();
	}

	private: System::Void DISPLAY_TASK_FLOAT_TextChanged(System::Object^  sender, System::EventArgs^  e) {
		//this section allows the text box to scroll to the end automatically
		//DISPLAY_TASK_FLOAT->SelectionStart = DISPLAY_TASK_FLOAT->TextLength;
		//DISPLAY_TASK_FLOAT->ScrollToCaret();
		//end section

	}
	private: System::Void DISPLAY_MAIN_TextChanged(System::Object^  sender, System::EventArgs^  e) {
		//this section allows the text box to scroll to the end automatically
		//DISPLAY_MAIN->SelectionStart = DISPLAY_MAIN->TextLength;
		//DISPLAY_MAIN->ScrollToCaret();
		//end section
	}	
	private: System::Void DISPLAY_TASK_TIMED_TextChanged(System::Object^  sender, System::EventArgs^  e) {
		//this section allows the text box to scroll to the end automatically
		//DISPLAY_TASK_TIMED->SelectionStart = DISPLAY_TASK_TIMED->TextLength;
		//DISPLAY_TASK_TIMED->ScrollToCaret();
		//end section
	}
	private: System::Void GUI_Load(System::Object^  sender, System::EventArgs^  e) {
	}
	private: System::Void INPUT_CMDLN_TextChanged(System::Object^  sender, System::EventArgs^  e) {
		string input = msclr::interop::marshal_as<std::string>(INPUT_CMDLN->Text);
		controller->QuickSearch(input);
		DISPLAY_MAIN->LoadFile(gcnew String(controller->rtf_main.c_str()));
	}

private: System::Void DISPLAY_TASK_DEADLINE_TextChanged(System::Object^  sender, System::EventArgs^  e) {
	//this section allows the text box to scroll to the end automatically
	//DISPLAY_TASK_DEADLINE->SelectionStart = DISPLAY_TASK_DEADLINE->TextLength;
	//DISPLAY_TASK_DEADLINE->ScrollToCaret();
	//end section
}
};
}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleGUI\GUI.h





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(STORAGE_TXT_ADD){
			string expected[2];
			vector<Task*> tasklist;
			//testing the partiton n>0; boundary case n = 1; where n is the number of tasks added
			Storage* storage = new Storage("Storage_Add.txt");
			storage->Clear();
			Task* task = new Task();
			task->SetDescription("do homework");
			task->SetEndDateTime("07/06/2015");
			task->SetStartDateTime("05/06/2015");
			task->SetPriority("1");
			task->SetStatus("Incomplete");
			storage->Add(task);

			expected[0] = "Description: do homework\nStart: 05/06/2015\nEnd: 07/06/2015\nPriority: 1\nStatus: Incomplete";
			Assert::AreEqual(expected[0], storage->GetTask(0));

			//testing the partition when n>1; boundary case n = 2; where n is the number of tasks added
			Task* task2 = new Task();
			task2->SetDescription("do homework 2");
			task2->SetEndDateTime("07/06/2015");
			task2->SetStartDateTime("05/06/2015");
			task2->SetPriority("12");
			task2->SetStatus("Complete");
			storage->Add(task2);
			//tasklist = storage->GetTaskList();

			expected[1] = "Description: do homework 2\nStart: 05/06/2015\nEnd: 07/06/2015\nPriority: 12\nStatus: Complete";
			Assert::AreEqual(expected[1], storage->GetTask(1));
			tasklist.clear();

		}
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(STORAGE_TXT_LOAD_REWRITE){
			//Testing the Load() and Rewrite() functions in storage
			//testing the partition when n > 1; boundary case n = 1; where n is the number of entries to be loaded and rewritten

			Storage* storage = new Storage("Unit_test_IO2.txt");
			storage->Clear();
			Task* task = new Task();
			task->SetDescription("do homework");
			task->SetEndDateTime("07/06/2015 at 4pm");
			task->SetStartDateTime("06/06/2015 at 3pm");
			task->SetPriority("1");
			task->SetStatus("Complete");
			storage->Add(task);

			task = new Task();
			task->SetDescription("do homework 2");
			task->SetEndDateTime("05/02/2015 at 1pm");
			task->SetStartDateTime("01/02/2015 at 1pm");
			task->SetPriority("1234");
			task->SetStatus("Incomplete");
			storage->Add(task);

			storage->Rewrite();

			delete storage;
			storage = new Storage();

			int size = storage->Size();
			Assert::IsTrue(size > 0);
			string expected[2];
			expected[1] = "Description: do homework\nStart: 03:00pm on 06/06/2015\nEnd: 04:00pm on 07/06/2015\nPriority: 1\nStatus: Complete";
			expected[0] = "Description: do homework 2\nStart: 01:00pm on 01/02/2015\nEnd: 01:00pm on 05/02/2015\nPriority: 1234\nStatus: Incomplete";

			for (int i = 0; i < size; i++){
				Assert::AreEqual(expected[i], storage->GetTask(i));
			}

		}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(PARSER_IdentifyTaskFields){
			Parser* parser = new Parser();
			//Case: fields with varied length
			string input = "go to school till: monday p: 1 from: today";
			vector<string> output = parser->IdentifyTaskFields(input);
			Assert::AreEqual(output[Smartstring::DESCRIPTION].c_str(), "go to school");
			Assert::AreEqual(output[Smartstring::STARTDATE].c_str(), "today"); //NEED TO CHANGE FORMAT FOR FINAL TEST
			Assert::AreEqual(output[Smartstring::PRIORITY].c_str(), "1");
			Assert::AreEqual(output[Smartstring::ENDDATE].c_str(), "monday"); //NEED TO CHANGE FORMAT FOR FINAL TEST

			//Case: fields with length 1
			input = "homework from: Monday priority: 1 end: Friday";
			output.clear();
			output = parser->IdentifyTaskFields(input);
			Assert::AreEqual(output[Smartstring::DESCRIPTION].c_str(), "homework");
			Assert::AreEqual(output[Smartstring::STARTDATE].c_str(), "Monday"); //NEED TO CHANGE FORMAT FOR FINAL TEST
			Assert::AreEqual(output[Smartstring::PRIORITY].c_str(), "1");
			Assert::AreEqual(output[Smartstring::ENDDATE].c_str(), "Friday"); //NEED TO CHANGE FORMAT FOR FINAL TEST
		}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(PARSER_IdentifyCommand){
			Parser* parser = new Parser();
			//Case: ADD
			string input = "add homework from: Monday priority: 1 end: Friday";
			int expected = Smartstring::COMMAND::ADD;
			int actual = parser->IdentifyCommand(input);
			Assert::AreEqual(expected, actual);

			//Case: CLEAR
			input = "clear file";
			expected = Smartstring::COMMAND::CLEAR;
			actual = parser->IdentifyCommand(input);
			Assert::AreEqual(expected, actual);

			//Case: DELETE
			input = "delete homework everyday";
			expected = Smartstring::COMMAND::DELETE;
			actual = parser->IdentifyCommand(input);
			Assert::AreEqual(expected, actual);

			//Case: DISPLAY
			input = "display all items";
			expected = Smartstring::COMMAND::DISPLAY;
			actual = parser->IdentifyCommand(input);
			Assert::AreEqual(expected, actual);

			//Case: EDIT
			input = "edit this item";
			expected = Smartstring::COMMAND::EDIT;
			actual = parser->IdentifyCommand(input);
			Assert::AreEqual(expected, actual);


			//Case: SEARCH
			input = "search homework";
			expected = Smartstring::COMMAND::SEARCH;
			actual = parser->IdentifyCommand(input);
			Assert::AreEqual(expected, actual);

		}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(PARSER_RemoveCommand){
			Parser* parser = new Parser();
			//Case: Test empty
			string input = "";
			string expected = "";
			string actual = parser->RemoveCommand(input);
			Assert::AreEqual(expected, actual);

			//Case: Test one word input
			input = "search";
			expected = "";
			actual = parser->RemoveCommand(input);
			Assert::AreEqual(expected, actual);

			//Case: Test more than one word input
			input = "search for homework";
			expected = "for homework";
			actual = parser->RemoveCommand(input);
			Assert::AreEqual(expected, actual);
		}

		TEST_METHOD(TASK){
			//default constructor test
			Task* task = new Task();
			Assert::AreEqual("", task->GetDescription().c_str());
			Assert::AreEqual("", task->GetStartDateTime().c_str());
			Assert::AreEqual("", task->GetEndDateTime().c_str());
			Assert::AreEqual("", task->GetPriority().c_str());

			//vector constructor test
			vector<string> testinput;
			testinput.push_back("do my homework");
			testinput.push_back("09/10/2015");
			testinput.push_back("10/10/2015");
			testinput.push_back("1");
			testinput.push_back("Incomplete");

			Task* vectTask = new Task(testinput);
			Assert::AreEqual("do my homework", vectTask->GetDescription().c_str());
			Assert::AreEqual("09/10/2015", vectTask->GetStartDateTime().c_str());
			Assert::AreEqual("10/10/2015", vectTask->GetEndDateTime().c_str());
			Assert::AreEqual("1", vectTask->GetPriority().c_str());
			Assert::AreEqual("Incomplete", vectTask->GetStatus().c_str());

			string actual = vectTask->ToCSVString();
			string expected = "\"do my homework\",\"09/10/2015\",\"10/10/2015\",\"1\",\"Incomplete\"";
			Assert::AreEqual(expected, actual);

		}

		TEST_METHOD(TASK_INTEGRATED){
			//default constructor test
			Task* task = new Task();
			Assert::AreEqual("", task->GetDescription().c_str());
			Assert::AreEqual("", task->GetStartDateTime().c_str());
			Assert::AreEqual("", task->GetEndDateTime().c_str());
			Assert::AreEqual("", task->GetPriority().c_str());

			//vector constructor test
			vector<string> testinput;
			testinput.push_back("do my homework");
			testinput.push_back("09/10/2015 at 5pm");
			testinput.push_back("10/10/2015 at 6pm");
			testinput.push_back("1");
			testinput.push_back("Incomplete");
			
			Task* vectTask = new Task(testinput);

			Assert::AreEqual("do my homework", vectTask->GetDescription().c_str());
			Assert::AreEqual("05:00pm on 09/10/2015", vectTask->GetStartDateTime().c_str());
			Assert::AreEqual("06:00pm on 10/10/2015", vectTask->GetEndDateTime().c_str());
			Assert::AreEqual("1", vectTask->GetPriority().c_str());
			Assert::AreEqual("Incomplete", vectTask->GetStatus().c_str());
			
		}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(SMARTSTRING_TOKENIZE){
			//testing the partition inpult length > 0
			string input = "\"hello\",\"how\",\"are\",\"you\",\"doing\",\"today\"";
			Smartstring str(input);
			vector<string> result = str.Tokenize(",\"");
			int size = result.size();
			Assert::AreEqual(6, size);
			Assert::AreEqual("hello", result[0].c_str());
			Assert::AreEqual("how", result[1].c_str());
			Assert::AreEqual("are", result[2].c_str());
			Assert::AreEqual("you", result[3].c_str());
			Assert::AreEqual("doing", result[4].c_str());
			Assert::AreEqual("today", result[5].c_str());

			//testing partition input length 0
			input = "";
			str = Smartstring(input);
			result = str.Tokenize(" ");
			size = result.size();
			Assert::AreEqual(size, 0);
		}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(DATETIME_USER_INPUTS){
			string input;
			string expected;
			string actual;
			DateTime dt2;
			//testing the partition where no day reset is crossed
			input = "Tuesday at 5pm";
			DateTime dt(input);
			actual = dt.Standardized();
			dt2 = DateTime("Tuesday");
			expected = "05:00pm on " + dt2.Standardized();
			Assert::AreEqual(expected, actual);

			input = "5pm on Tuesday";
			dt = DateTime(input);
			actual = dt.Standardized();
			dt2 = DateTime("Tuesday");
			expected = "05:00pm on " + dt2.Standardized();
			Assert::AreEqual(expected, actual);

			input = "Friday at 10pm";
			dt = DateTime(input);
			actual = dt.Standardized();
			dt2 = DateTime("Friday");
			expected = "10:00pm on " + dt2.Standardized();
			Assert::AreEqual(expected, actual);

			//testing the partition where a day reset is crossed e.g today is wednesday, appointment on monday
			input = "Monday at 6pm";
			dt = DateTime(input);
			actual = dt.Standardized();
			dt2 = DateTime("Monday");
			expected = "06:00pm on " + dt2.Standardized();
			Assert::AreEqual(expected, actual);

			//testing that Standardized() does not change empty strings
			input = "";
			dt = DateTime(input);
			actual = dt.Standardized();
			expected = "";
			Assert::AreEqual(expected, actual);

			//test the partition where only a time is set
			input = "5pm";
			dt = DateTime(input);
			actual = dt.Standardized();
			expected = "05:00pm";
			Assert::AreEqual(expected, actual);

			//To test the today and tomorrow keywords, modify the expected date as you desire
			////testing today and tomorrow keywords
			//input = "today";
			//dt = DateTime(input);
			//actual = dt.Standardized();
			//expected = "08/04/2015";
			//Assert::AreEqual(expected, actual);

			//input = "tomorrow";
			//dt = DateTime(input);
			//actual = dt.Standardized();
			//expected = "09/04/2015";
			//Assert::AreEqual(expected, actual);

			//important lacking test: testing when month is crossed

		}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(DATETIME_STANDARD_INPUTS){
			string input;
			string expected[10];
			string actual[10];
			DateTime dt;

			//testing that standard inputs can be reconstructed
			input = "06:00pm on 13/04/2015";
			dt = DateTime(input);
			actual[0] = dt.Standardized();
			expected[0] = "06:00pm on 13/04/2015";
			Assert::AreEqual(expected[0], actual[0]);

			input = "13/04/2015 at 06:00pm";
			dt = DateTime(input);
			actual[3] = dt.Standardized();
			expected[3] = "06:00pm on 13/04/2015";
			Assert::AreEqual(expected[3], actual[3]);

			//testing date only input
			input = "13/04/2015";
			dt = DateTime(input);
			actual[1] = dt.Standardized();
			expected[1] = "13/04/2015";
			Assert::AreEqual(expected[1], actual[1]);

			//testing time only input
			input = "05:30pm";
			dt = DateTime(input);
			actual[2] = dt.Standardized();
			expected[2] = "05:30pm";
			Assert::AreEqual(expected[2], actual[2]);

		}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(DATETIME_INTERNAL_INFO){
			string input;
			string expected[10];
			string actual[10];
			DateTime dt;

			input = "13/04/2015";
			dt = DateTime(input);
			actual[0] = dt.GetInfo();
			expected[0] = "Date: 13/04/2015\nTime: 00:00";
			Assert::AreEqual(expected[0], actual[0]);

			input = "13/04/2015 at 5pm";
			dt = DateTime(input);
			actual[1] = dt.GetInfo();
			expected[1] = "Date: 13/04/2015\nTime: 17:00";
			Assert::AreEqual(expected[1], actual[1]);

			input = "13/04/2014 at 7:30am";
			dt = DateTime(input);
			actual[2] = dt.GetInfo();
			expected[2] = "Date: 13/04/2014\nTime: 07:30";
			Assert::AreEqual(expected[2], actual[2]);

			//This test tests the assumption that the date is assumed to be the current day if no day is specified
			input = "8:09pm";
			dt = DateTime(input);
			string currentdate = dt.Today();
			actual[3] = dt.GetInfo();
			expected[3] = "Date: " + currentdate + "\nTime: 20:09";
			Assert::AreEqual(expected[3], actual[3]);

		}

	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





	/**
	 * origin: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp
	 */

		TEST_METHOD(DATETIME_ISEARLIERTHAN){
			string date1;
			string date2;
			DateTime dt1;
			DateTime dt2;
			
			//testing the partition where only dates are inputs
			date1 = "07/04/2014";
			date2 = "08/04/2014";
			dt1 = DateTime(date1);
			dt2 = DateTime(date2);
			Assert::IsTrue(dt1.IsEarlierThan(dt2));

			//testing the partition where only times are inputs
			date1 = "5pm";
			date2 = "6pm";
			dt1 = DateTime(date1);
			dt2 = DateTime(date2);
			Assert::IsTrue(dt1.IsEarlierThan(dt2));

			//testing the partition where dates are equal but time is greater
			date1 = "07/04/2014 at 5pm";
			date2 = "07/04/2014 at 6pm";
			dt1 = DateTime(date1);
			dt2 = DateTime(date2);
			Assert::IsTrue(dt1.IsEarlierThan(dt2));

			//testing the function returning false when condition is not satisfied
			date1 = "07/04/2014 at 6pm";
			date2 = "07/04/2014 at 5pm";
			dt1 = DateTime(date1);
			dt2 = DateTime(date2);
			Assert::IsFalse(dt1.IsEarlierThan(dt2));

			//testing the partition where dates are different but time is equal
			date1 = "07/04/2014 at 5pm";
			date2 = "08/04/2014 at 5pm";
			dt1 = DateTime(date1);
			dt2 = DateTime(date2);
			Assert::IsTrue(dt1.IsEarlierThan(dt2));

			//testing case
	// End of segment: C:\Users\conra_000\Desktop\Collate Tool\I_Schedule source\I_ScheduleLibraryTest\Libtest.cpp





